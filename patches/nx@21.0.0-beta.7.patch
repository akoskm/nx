diff --git a/.idea/72dc59eeaccdbadea0aee5b43a3f9a53.iml b/.idea/72dc59eeaccdbadea0aee5b43a3f9a53.iml
new file mode 100644
index 0000000000000000000000000000000000000000..d6ebd4805981b8400db3e3291c74a743fef9a824
--- /dev/null
+++ b/.idea/72dc59eeaccdbadea0aee5b43a3f9a53.iml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000000000000000000000000000000000000..639900d13c6182e452e33a3bd638e70a0146c785
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 0000000000000000000000000000000000000000..0b8bc9ba7da151d6336029cc1a810b51c6bd5f1f
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/72dc59eeaccdbadea0aee5b43a3f9a53.iml" filepath="$PROJECT_DIR$/.idea/72dc59eeaccdbadea0aee5b43a3f9a53.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/src/executors/run-commands/running-tasks.js b/src/executors/run-commands/running-tasks.js
index 5ecf36fd9062120afd92530ba6b15f542d04c810..34adf6d39bf9f1708b7d1fc4e305b00a4ca3e941 100644
--- a/src/executors/run-commands/running-tasks.js
+++ b/src/executors/run-commands/running-tasks.js
@@ -364,6 +364,10 @@ function processEnv(color, cwd, envOptionFromExecutor, envFile) {
     if (color) {
         res.FORCE_COLOR = `${color}`;
     }
+
+    console.log(`finished 'processEnv': processed PATH`)
+    console.log(process.env.PATH)
+
     return res;
 }
 function isReady(readyWhenStatus = [], data) {
diff --git a/src/executors/run-script/run-script.impl.js b/src/executors/run-script/run-script.impl.js
index 161e0f312156d61186afeb93980778f88f8021df..e89c135283808e85ed14dd6e9bcc45ccba6559c1 100644
--- a/src/executors/run-script/run-script.impl.js
+++ b/src/executors/run-script/run-script.impl.js
@@ -11,6 +11,11 @@ async function default_1(options, context) {
         let command = pm.run(options.script, options.__unparsed__.join(' '));
         let cwd = path.join(context.root, context.projectsConfigurations.projects[context.projectName].root);
         let env = process.env;
+
+        console.log("run-script.impl.js");
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
         // when running nx through npx with node_modules installed with npm, the path gets modified to include the full workspace path with the node_modules folder
         // This causes issues when running in a pty process, so we filter out the node_modules paths from the PATH
         // Since the command here will be run with the package manager script command, the path will be modified again within the PTY process itself.
@@ -18,6 +23,7 @@ async function default_1(options, context) {
             .filter((p) => !p.startsWith(path.join(context.root, 'node_modules')))
             .join(path.delimiter) ?? '';
         env.PATH = filteredPath;
+
         if (pseudo_terminal_1.PseudoTerminal.isSupported()) {
             await ptyProcess(command, cwd, env);
         }
@@ -31,6 +37,10 @@ async function default_1(options, context) {
     }
 }
 function nodeProcess(command, cwd, env) {
+    console.log(`run-script.impl.js.nodeProcess`);
+    console.log(JSON.stringify(process.env, null, 2));
+    console.log('---------------------')
+
     (0, child_process_1.execSync)(command, {
         stdio: ['inherit', 'inherit', 'inherit'],
         cwd,
@@ -39,6 +49,10 @@ function nodeProcess(command, cwd, env) {
     });
 }
 async function ptyProcess(command, cwd, env) {
+    console.log(`run-script.impl.js.ptyProcess`);
+    console.log(JSON.stringify(process.env, null, 2));
+    console.log('---------------------')
+
     const terminal = (0, pseudo_terminal_1.createPseudoTerminal)();
     await terminal.init();
     return new Promise((res, rej) => {
diff --git a/src/tasks-runner/forked-process-task-runner.js b/src/tasks-runner/forked-process-task-runner.js
index 13f711170b76fea57ecf58207ff961069249c259..e06277ee1ff4f0a6dea51448b18b4731c0ba7e2e 100644
--- a/src/tasks-runner/forked-process-task-runner.js
+++ b/src/tasks-runner/forked-process-task-runner.js
@@ -26,6 +26,10 @@ class ForkedProcessTaskRunner {
         this.pseudoTerminals = new Set();
     }
     async init() {
+        console.log(`forked-process-task-runner.init`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
         this.setupProcessEventListeners();
     }
     // TODO: vsavkin delegate terminal output printing
@@ -84,6 +88,15 @@ class ForkedProcessTaskRunner {
         const shouldPrefix = streamOutput &&
             process.env.NX_PREFIX_OUTPUT === 'true' &&
             !this.tuiEnabled;
+
+        console.log(`forked-process-task-runner.forkProcess`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
+        console.log(`forked-process-task-runner.forkProcess params`);
+        console.log(JSON.stringify(env, null, 2));
+        console.log('---------------------')
+
         // streamOutput would be false if we are running multiple targets
         // there's no point in running the commands in a pty if we are not streaming the output
         if (pseudo_terminal_1.PseudoTerminal.isSupported() &&
@@ -117,6 +130,15 @@ class ForkedProcessTaskRunner {
         const childId = task.id;
         const pseudoTerminal = await this.createPseudoTerminal();
         this.pseudoTerminals.add(pseudoTerminal);
+
+        console.log(`forked-process-task-runner.forkProcessWithPseudoTerminal`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
+        console.log(`forked-process-task-runner.forkProcessWithPseudoTerminal params`);
+        console.log(JSON.stringify(env, null, 2));
+        console.log('---------------------')
+
         const p = await pseudoTerminal.fork(childId, forkScript, {
             cwd: process.cwd(),
             execArgv: process.execArgv,
@@ -153,6 +175,15 @@ class ForkedProcessTaskRunner {
             if (streamOutput) {
                 output_1.output.logCommand(args.join(' '));
             }
+
+            console.log(`forked-process-task-runner.forkProcessWithPrefixAndNotTTY`);
+            console.log(JSON.stringify(process.env, null, 2));
+            console.log('---------------------')
+
+            console.log(`forked-process-task-runner.forkProcessWithPrefixAndNotTTY params`);
+            console.log(JSON.stringify(env, null, 2));
+            console.log('---------------------')
+
             const p = (0, child_process_1.fork)(this.cliPath, {
                 stdio: ['inherit', 'pipe', 'pipe', 'ipc'],
                 env,
diff --git a/src/tasks-runner/pseudo-terminal.js b/src/tasks-runner/pseudo-terminal.js
index 6a0ad0fa3a69a4f85126cfc6b887238a9399e0a5..bc859609d1f812061c8048a546958df79affe103 100644
--- a/src/tasks-runner/pseudo-terminal.js
+++ b/src/tasks-runner/pseudo-terminal.js
@@ -52,9 +52,17 @@ class PseudoTerminal {
         }
     }
     runCommand(command, { cwd, execArgv, jsEnv, quiet, tty, } = {}) {
+        console.log(`pseudo-terminal.runCommand`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
         return new PseudoTtyProcess(this.rustPseudoTerminal, this.rustPseudoTerminal.runCommand(command, cwd, jsEnv, execArgv, quiet, tty));
     }
     async fork(id, script, { cwd, execArgv, jsEnv, quiet, }) {
+        console.log(`pseudo-terminal.fork`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
         if (!this.initialized) {
             throw new Error('Call init() before forking processes');
         }
diff --git a/src/tasks-runner/task-env.js b/src/tasks-runner/task-env.js
index 879dd7e11af76677dcf80566299ae81cafb49147..2efe34fb6e5b064442613c50061553aef3cd2a83 100644
--- a/src/tasks-runner/task-env.js
+++ b/src/tasks-runner/task-env.js
@@ -19,19 +19,47 @@ function getEnvVariablesForBatchProcess(skipNxCache, captureStderr) {
 }
 function getTaskSpecificEnv(task) {
     // Unload any dot env files at the root of the workspace that were loaded on init of Nx.
+
+    console.log("taskEnv.getTaskSpecificEnv");
+    console.log(JSON.stringify(process.env, null, 2));
+    console.log('---------------------')
+
+    console.log("taskEnv.getTaskSpecificEnv values");
+
     const taskEnv = unloadDotEnvFiles({ ...process.env });
+    console.log("taskEnv")
+    console.log(JSON.stringify(taskEnv, null, 2));
+
+    console.log("NX_LOAD_DOT_ENV_FILES: ", process.env.NX_LOAD_DOT_ENV_FILES);
+
     return process.env.NX_LOAD_DOT_ENV_FILES === 'true'
         ? loadDotEnvFilesForTask(task, taskEnv)
         : // If not loading dot env files, ensure env vars created by system are still loaded
             taskEnv;
 }
 function getEnvVariablesForTask(task, taskSpecificEnv, forceColor, skipNxCache, captureStderr, outputPath, streamOutput) {
+
+    console.log("taskEnv.getEnvVariablesForTask");
+    console.log(JSON.stringify(process.env, null, 2));
+    console.log('---------------------')
+
+    console.log("taskSpecificEnv.getEnvVariablesForTask values");
+    console.log("taskSpecificEnv")
+    console.log(JSON.stringify(taskSpecificEnv, null, 2));
+
+
     const res = {
         // Start With Dotenv Variables
         ...taskSpecificEnv,
         // Nx Env Variables overrides everything
         ...getNxEnvVariablesForTask(task, forceColor, skipNxCache, captureStderr, outputPath, streamOutput),
     };
+
+    console.log("res")
+    console.log(JSON.stringify(res, null, 2));
+    console.log('---------------------')
+
+
     // we have to delete it because if we invoke Nx from within Nx, we need to reset those values
     if (!outputPath) {
         delete res.NX_TERMINAL_OUTPUT_PATH;
@@ -104,8 +132,14 @@ function loadAndExpandDotEnvFile(filename, environmentVariables, override = fals
 function unloadDotEnvFile(filename, environmentVariables, override = false) {
     const parsedDotEnvFile = {};
     loadAndExpandDotEnvFile(filename, parsedDotEnvFile, override);
+
+    console.log("parsedDotEnvFile")
+    console.log(JSON.stringify(parsedDotEnvFile, null, 2));
+
     Object.keys(parsedDotEnvFile).forEach((envVarKey) => {
+        console.log("Evaluating key: ", envVarKey);
         if (environmentVariables[envVarKey] === parsedDotEnvFile[envVarKey]) {
+            console.log("Deleting key: ", envVarKey, 'with value: ', parsedDotEnvFile[envVarKey]);
             delete environmentVariables[envVarKey];
         }
     });
@@ -166,8 +200,18 @@ function loadDotEnvFilesForTask(task, environmentVariables) {
     return environmentVariables;
 }
 function unloadDotEnvFiles(environmentVariables) {
+    console.log("unloadDotEnvFiles");
+    console.log("Baseline")
+    console.log(JSON.stringify(environmentVariables, null, 2));
+
+
     for (const file of ['.env', '.local.env', '.env.local']) {
+        console.log("Unloading: ", file);
         unloadDotEnvFile((0, node_path_1.join)(workspace_root_1.workspaceRoot, file), environmentVariables);
+
+        console.log("After Unloading: ", file);
+        console.log("Baseline")
+        console.log(JSON.stringify(environmentVariables, null, 2));
     }
     return environmentVariables;
 }
diff --git a/src/tasks-runner/task-orchestrator.js b/src/tasks-runner/task-orchestrator.js
index b8754a79c8d3166c76ad3eb78f53bec3926e25cc..a8acf41efb2d0ed6c4cdee6a193c38ca764272ed 100644
--- a/src/tasks-runner/task-orchestrator.js
+++ b/src/tasks-runner/task-orchestrator.js
@@ -61,6 +61,10 @@ class TaskOrchestrator {
             this.tasksSchedule.init(),
             'init' in this.cache ? this.cache.init() : null,
         ]);
+
+        console.log(`task-orchestrator.init`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
     }
     async run() {
         await this.init();
@@ -243,10 +247,15 @@ class TaskOrchestrator {
     // endregion Batch
     // region Single Task
     async applyFromCacheOrRunTask(doNotSkipCache, task, groupId) {
+
+        console.log(`task-orchestrator.applyFromCacheOrRunTask`);
+        console.log(JSON.stringify(process.env, null, 2));
+
         // Wait for task to be processed
         const taskSpecificEnv = await this.processedTasks.get(task.id);
         await this.preRunSteps([task], { groupId });
         const pipeOutput = await this.pipeOutputCapture(task);
+        console.log("pipeOutput: ", pipeOutput);
         // obtain metadata
         const temporaryOutputPath = this.cache.temporaryOutputPath(task);
         const streamOutput = this.outputStyle === 'static'
@@ -258,6 +267,10 @@ class TaskOrchestrator {
                 : process.env.FORCE_COLOR, this.options.skipNxCache, this.options.captureStderr, null, null)
             : (0, task_env_1.getEnvVariablesForTask)(task, taskSpecificEnv, undefined, this.options.skipNxCache, this.options.captureStderr, temporaryOutputPath, streamOutput);
         let results = doNotSkipCache ? await this.applyCachedResults([task]) : [];
+
+        console.log('---------------------')
+
+
         // the task wasn't cached
         if (results.length === 0) {
             const childProcess = await this.runTask(task, streamOutput, env, temporaryOutputPath, pipeOutput);
@@ -275,6 +288,15 @@ class TaskOrchestrator {
     async runTask(task, streamOutput, env, temporaryOutputPath, pipeOutput) {
         const shouldPrefix = streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';
         const targetConfiguration = (0, utils_1.getTargetConfigurationForTask)(task, this.projectGraph);
+
+        console.log(`task-orchestrator.runTask`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
+        console.log(`task-orchestrator.runTask params`);
+        console.log(JSON.stringify(env, null, 2));
+        console.log('---------------------')
+
         if (process.env.NX_RUN_COMMANDS_DIRECTLY !== 'false' &&
             targetConfiguration.executor === 'nx:run-commands' &&
             !shouldPrefix) {
@@ -376,6 +398,14 @@ class TaskOrchestrator {
         }
     }
     async runTaskInForkedProcess(task, env, pipeOutput, temporaryOutputPath, streamOutput) {
+        console.log(`task-orchestrator.runTaskInForkedProcess`);
+        console.log(JSON.stringify(process.env, null, 2));
+        console.log('---------------------')
+
+        console.log(`task-orchestrator.runTaskInForkedProcess params`);
+        console.log(JSON.stringify(env, null, 2));
+        console.log('---------------------')
+
         try {
             const usePtyFork = process.env.NX_NATIVE_COMMAND_RUNNER !== 'false';
             // Disable the pseudo terminal if this is a run-many or when running a continuous task as part of a run-one
